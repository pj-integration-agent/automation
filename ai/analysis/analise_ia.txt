## 1. Testes que falharam

| Horário | Descrição do teste | Motivo imediato |
|--------|---------------------|-----------------|
| 18:45:03.917 | **Login inválido falhou** | `expect(locator('.error')).toContainText(...)` retornou erro. |
| 18:45:05.585 | **Usuário deve atualizar telefone com campo vazio falhou** | `expect(locator('//*[@id="phone-error"]')).toContainText(...)` não encontrou o elemento e o texto esperado. |

---

## 2. Motivo de cada falha

### 2.1. Login inválido falhou

| Item | Detalhe |
|------|---------|
| **Locador** | `locator('.error')` |
| **Texto esperado** | `"An internal error has occurred and has been logged."` (note a palavra **logged** com *g* no final) |
| **Texto recebido** | `"The username and password could not be verified."` |
| **Tempo de espera** | 5000 ms |
| **Causa provável** |  |
| 1. **Mensagem de erro inesperada** – o sistema não está emitindo o erro interno, mas sim a mensagem padrão de login incorreto. Isso pode ocorrer quando o back‑end ainda não está configurado para lançar erros internos ou o front‑end tem a lógica “fallback” para mostrar a mensagem “username/password could not be verified”. |
| 2. **Assertivo com texto errado** – o teste foi escrito pensando em um comportamento que mudou. A mensagem de erro interna (que parece ser um erro de produção) não deveria ser exibida a um usuário comum. |

> **Resumo**: O teste espera uma mensagem de “erro interno”, mas a aplicação devolve a mensagem “The username and password could not be verified.”

### 2.2. Usuário deve atualizar telefone com campo vazio falhou

| Item | Detalhe |
|------|---------|
| **Locador** | `locator('//*[@id="phone-error"]')` |
| **Texto esperado** | `"Phone is required."` |
| **Erro** | `element(s) not found` |
| **Tempo de espera** | 5000 ms |
| **Causa provável** |  |
| 1. **Elemento não existe** – o erro não aparece na página, talvez porque o campo de telefone esteja oculto, renomeado ou a validação esteja acontecendo antes da renderização do elemento. |
| 2. **ID incorreto ou XPath errado** – o XPath usado pode estar incorreto, especialmente se a estrutura do DOM mudou (por exemplo, `id="phone-error"` foi alterado para `id="phone-error-msg"`). |
| 3. **Validação não acionada** – o formulário pode não estar enviando a requisição de validação quando o campo está vazio, caso a lógica de validação client‑side esteja falhando ou o teste não esteja submetendo o formulário corretamente. |

> **Resumo**: O teste não encontra o elemento de erro porque ele não está presente no DOM naquele momento.

---

## 3. Sugestões de correção

### 3.1. Corrigir o teste de login inválido

| Estratégia | Como fazer | Por que funciona |
|------------|------------|------------------|
| **Atualizar a mensagem esperada** | Modifique o `expect` para usar a mensagem real:  |
| | ```js\nawait expect(page.locator('.error')).toContainText('The username and password could not be verified.');\n``` | O teste refletirá o comportamento real da aplicação. |
| **Adicionar fallback** | Se o sistema pode exibir duas mensagens (erro interno ou mensagem de login), use `or` logic: |
| | ```js\nconst errorLocator = page.locator('.error');\nawait Promise.all([\n  errorLocator.waitFor({ state: 'visible', timeout: 5000 }),\n  expect(errorLocator).toContainText(/(An internal error has occurred|The username and password could not be verified)/),\n]);\n``` | Garante que o teste passe mesmo que o erro interno não seja gerado. |
| **Testar apenas a mensagem de login** | Se o erro interno não deve ser mostrado ao usuário, remova a expectativa e teste apenas a mensagem de login. | Mantém o teste alinhado com a experiência do usuário. |
| **Verificar se o back‑end está lançando erro** | Se a intenção era testar que a API devolvesse um erro interno, mova essa verificação para um teste de API separado (e não de UI). | UI não deve depender de erros internos de back‑end; isso pode ser testado em testes de integração ou de unidade. |

### 3.2. Corrigir o teste de telefone vazio

| Estratégia | Como fazer | Por que funciona |
|------------|------------|------------------|
| **Confirmar o ID do elemento** | Abra o aplicativo em modo de desenvolvedor, inspecione o elemento de erro de telefone e verifique se o `id` realmente é `phone-error`. Se for outro, atualize o XPath/selector: |
| | ```js\nawait expect(page.locator('#phone-error')).toContainText('Phone is required.');\n``` | Garante que o selector esteja correto. |
| **Usar um selector mais robusto** | Se o ID pode mudar, use um atributo mais estável, por ex.: `data-test-id="phone-error"` ou a relação com o label/placeholder: |
| | ```js\nawait expect(page.locator('form >> text="Phone is required."')).toBeVisible();\n``` | Evita dependência de IDs que podem ser alterados. |
| **Assegurar que o formulário está enviado** | Adicione uma etapa que submete o formulário antes de esperar pelo erro: |
| | ```js\nawait page.fill('#phone', '');\nawait page.click('button[type=submit]');\nawait expect(page.locator('#phone-error')).toBeVisible();\n``` | Garante que a validação client‑side seja acionada. |
| **Aumentar o timeout se necessário** | Se o campo de telefone precisa de mais tempo para exibir o erro (por exemplo, após uma chamada Ajax), aumente o timeout ou use `waitForFunction`: |
| | ```js\nawait expect(page.locator('#phone-error')).toBeVisible({ timeout: 10000 });\n``` | Evita falhas por latência. |
| **Verificar lógica de validação** | Se a validação está sendo feita no servidor, o teste de UI pode precisar de dados válidos no lado do cliente (cookies, token). Certifique-se de que o contexto está autenticado. | |
| **Criar teste de unidade de validação** | Se a lógica de validação é complexa, mova-a para testes de unidade em vez de UI. | Reduz a dependência de DOM. |

---

## 4. Boas práticas para evitar essas falhas no futuro

1. **Use mensagens de erro claras e estáveis** – se o erro interno não deve ser exposto, não inclua-o em testes de UI.
2. **Evite locadores frágeis** – prefira `data-test-*` ou textos visíveis, que são menos propensos a mudar.
3. **Separação de responsabilidades** – teste a lógica de negócios em testes de API/união; teste a renderização de mensagens apenas em testes de UI.
4. **Logs detalhados** – inclua no log o `html()` do elemento falhado (`await page.locator('.error').innerHTML()`) para facilitar o diagnóstico.
5. **Assertivas condicionais** – use `or` / `anyOf` quando o sistema pode exibir múltiplas mensagens, mantendo o teste robusto a mudanças de mensagem.

---

## 5. Resumo rápido

| Teste | Falha | Motivo | Correção rápida |
|-------|-------|--------|-----------------|
| **Login inválido** | `toContainText` falhou | Mensagem esperada difere da recebida | Atualizar o texto esperado ou usar regex flexível |
| **Telefone vazio** | Elemento não encontrado | XPath ou ID errado / validação não acionada | Confirme o seletor, submeta o formulário, aumente timeout |

Com esses ajustes, os testes deverão passar de forma confiável e refletir corretamente o comportamento real da aplicação.