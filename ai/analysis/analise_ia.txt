## 1️⃣ Quais testes falharam?

| N° | Nome do Teste | Status |
|----|---------------|--------|
| 1  | **Login inválido** | **Falhou** |
| 2  | **Usuário deve atualizar telefone com sucesso** | **Falhou** |
| 3  | **Login válido** | **Falhou** |
| 4  | **Usuário deve atualizar telefone com campo vazio** | **Falhou** |

Todos os quatro testes registraram falhas no log do Playwright.

---

## 2️⃣ Motivo de cada falha

| N° | Falha | Mensagem de erro | Por quê? |
|----|--------|------------------|----------|
| 1  | **Login inválido** | `expect(locator).toBeVisible(...) failed`<br>Locator: `input[name="username"]`<br>Timeout: 5000 ms<br>Element(s) not found | O Playwright esperava que o campo de usuário estivesse visível, mas nunca o encontrou. Isso pode acontecer se: <br>• A página não foi navegada até o formulário de login (página vazia ou outra rota). <br>• O seletor está errado ou mudou no HTML. <br>• O campo está dentro de um iframe/Shadow DOM que não foi acessado. |
| 2  | **Usuário deve atualizar telefone com sucesso** | `Test timeout of 10000ms exceeded.` | O teste excedeu o tempo máximo permitido (10 s) sem terminar. Provavelmente o fluxo de atualização de telefone envolvia: <br>• Uma chamada assíncrona que não terminou dentro do intervalo. <br>• Um seletor de sucesso (mensagem, ícone, etc.) que nunca apareceu. <br>• Um atraso de carregamento da página/iframe que não foi tratado. |
| 3  | **Login válido** | Igual à falha 1. | Mesmo motivo: o campo `input[name="username"]` não apareceu. |
| 4  | **Usuário deve atualizar telefone com campo vazio** | `Test timeout of 10000ms exceeded.` | Mesmo motivo do teste 2, mas com a situação de campo vazio. |

---

## 3️⃣ Sugestões de Correção

### 3.1. Falhas de visibilidade (`Login inválido` / `Login válido`)

| Problema | Solução Recomendada | Código de Exemplo |
|----------|---------------------|-------------------|
| **Página não foi carregada** | Assegure‑se de chamar `page.goto()` (ou `await context.newPage()` + `goto`) antes de procurar o seletor. | ```js<br>await page.goto('/login');<br>``` |
| **Seletor errado** | Revise o HTML da página. Use DevTools para pegar o atributo exato (`name`, `id`, `class`). Se o elemento estiver em um `<form>` específico, inclua o caminho completo. | ```js<br>await expect(page.locator('form#loginForm input[name="username"]')).toBeVisible();<br>``` |
| **Elemento dentro de iframe** | Use `frameLocator` para alcançar o iframe. | ```js<br>const frame = page.frame({ name: 'auth-frame' });<br>await expect(frame.locator('input[name="username"]')).toBeVisible();<br>``` |
| **Elemento escondido/oculto** | Se o campo só aparece depois de algum evento (ex.: click em “Login”), execute esse evento antes. | ```js<br>await page.click('#show-login');<br>await expect(page.locator('input[name="username"]')).toBeVisible();<br>``` |
| **Timeout muito curto** | Aumente o timeout localmente se a página demorar mais. | ```js<br>await expect(page.locator('input[name="username"]')).toBeVisible({ timeout: 10000 });<br>``` |

> **Dica extra:** Use `await page.waitForLoadState('networkidle')` logo após `goto()` para garantir que todas as requisições foram concluídas antes de procurar os elementos.

---

### 3.2. Falhas de Timeout (`Usuário deve atualizar telefone`)

| Problema | Solução Recomendada | Código de Exemplo |
|----------|---------------------|-------------------|
| **Chamada de backend lenta** | Espere a resposta da API antes de verificar a UI. Use `page.waitForResponse` com a URL ou `request.method` esperados. | ```js<br>await Promise.all([<br>  page.click('#updatePhone'),<br>  page.waitForResponse(response => response.url().includes('/api/phone') && response.status() === 200)<br>]);<br>``` |
| **Elemento de sucesso não aparece** | Identifique o seletor do toast/alert/label que confirma a atualização e espere por ele. | ```js<br>await expect(page.locator('.toast-success')).toBeVisible();<br>``` |
| **Tempo de espera insuficiente** | Aumente o timeout geral do teste ou do `expect` específico. | ```js<br>await expect(page.locator('#phoneStatus')).toBeVisible({ timeout: 15000 });<br>``` |
| **Erros de navegação** | Se a atualização redireciona para outra página, use `waitForNavigation`. | ```js<br>await Promise.all([<br>  page.click('#updatePhone'),<br>  page.waitForNavigation({ waitUntil: 'load' })<br>]);<br>``` |
| **Campo obrigatório vazio** | Para o teste de campo vazio, certifique que o erro de validação aparece (ex.: `input:invalid`). | ```js<br>await page.fill('#phone', '');<br>await page.click('#updatePhone');<br>await expect(page.locator('#phoneError')).toBeVisible();<br>``` |

---

### 3.3. Boas práticas gerais

1. **Use `await expect(locator).toBeVisible()` apenas após garantir que a página ou iframe já está carregado.**
2. **Sempre capture um screenshot ou trace (`await page.screenshot({ path: 'debug.png' })` ou `await page.tracing.start(); ... await page.tracing.stop({ path: 'trace.zip' });`) quando uma falha ocorrer. Isso facilita a inspeção visual.**
3. **Adicione `console.log` ou `debugger;` antes de cada ação crítica para rastrear o fluxo de execução.**
4. **Evite `page.waitForTimeout(…)`; prefira esperas explícitas de elementos ou de respostas de rede.**
5. **Mantenha os seletores **relativos** ao contexto mais próximo (formulário, modal, iframe) para reduzir colisões e evitar mudanças no layout global.**

---

## 4️⃣ Exemplo de refatoração para o teste de login

```js
test.describe('Login', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login');
    await page.waitForLoadState('networkidle'); // garante que todas as requisições acabaram
  });

  test('Login inválido', async ({ page }) => {
    await page.fill('input[name="username"]', 'user123');
    await page.fill('input[name="password"]', 'wrongPassword');
    await page.click('button[type="submit"]');

    // Espera pelo toast de erro
    await expect(page.locator('.toast-error')).toBeVisible({ timeout: 8000 });
  });

  test('Login válido', async ({ page }) => {
    await page.fill('input[name="username"]', 'user123');
    await page.fill('input[name="password"]', 'correctPassword');
    await Promise.all([
      page.waitForNavigation({ waitUntil: 'networkidle' }),
      page.click('button[type="submit"]')
    ]);

    await expect(page.locator('h1')).toHaveText('Dashboard', { timeout: 8000 });
  });
});
```

---

## 5️⃣ Resumo rápido

| Teste | Falha | Causa provável | Correção rápida |
|-------|-------|----------------|-----------------|
| Login inválido | Elemento não encontrado | Seletor errado / página não carregada | Corrija seletor e adicione `goto`/`waitForLoadState` |
| Login válido | Elemento não encontrado | Mesmo que acima | Idem |
| Atualizar telefone (sucesso) | Timeout | Falta de espera por resposta ou UI | Use `waitForResponse`, espere pelo toast, aumente timeout |
| Atualizar telefone (vazio) | Timeout | Falta de espera por validação | Espere pelo erro de campo, aumente timeout |

Com esses ajustes, os testes devem passar e o seu pipeline ficará mais robusto. Boa codificação!