**1. Testes que falharam**

| Data | Nome do teste | Resultado |
|------|---------------|-----------|
| 2025‚Äë12‚Äë12 18:48:28 | **Login inv√°lido falhou** | Falhou |
| 2025‚Äë12‚Äë12 18:48:30 | **Usu√°rio deve atualizar telefone com campo vazio falhou** | Falhou |

---

## 2. Motivo de cada falha

### 2.1. Teste ‚ÄúLogin inv√°lido falhou‚Äù

**O que aconteceu**

```text
Error: expect(locator).toContainText(expected) failed
Locator: locator('.error')
Expected substring: "An internal error has occurred and has been logged."
Received string:    "The username and password could not be verified."
```

- O seletor **`.error`** encontrou o elemento `<p class="error">The username and password could not be verified.</p>`.
- O teste esperava *‚ÄúAn internal error has occurred and has been logged.‚Äù*.
- O erro retornado pelo sistema foi diferente ‚Äì mensagem de *‚ÄúThe username and password could not be verified.‚Äù*.
- O `toContainText` falhou porque a substring esperada n√£o est√° presente no texto real.

**Probabilidades de causa**

1. **Mudan√ßa no fluxo de erro** ‚Äì Talvez o backend tenha alterado a mensagem de erro, ou o front‚Äëend passou a exibir uma mensagem gen√©rica quando o login falha.
2. **Erro no teste** ‚Äì O teste pode estar escrito com a mensagem antiga que n√£o reflete a realidade da aplica√ß√£o.
3. **Ambiente de teste** ‚Äì Se o ambiente de teste estiver apontando para um backend diferente (ex.: staging vs produ√ß√£o) a mensagem pode diferir.

### 2.2. Teste ‚ÄúUsu√°rio deve atualizar telefone com campo vazio falhou‚Äù

**O que aconteceu**

```text
Error: expect(locator).toContainText(expected) failed
Locator: locator('//*[@id="phone-error"]')
Expected substring: "Phone is required."
Timeout: 5000ms
Error: element(s) not found
```

- O seletor **`//*[@id="phone-error"]`** n√£o encontrou nenhum elemento at√© o timeout de 5‚ÄØs.
- Como n√£o h√° elemento, n√£o h√° texto para comparar.
- O teste n√£o conseguiu validar a mensagem de erro ‚ÄúPhone is required.‚Äù.

**Probabilidades de causa**

1. **Elemento n√£o renderizado** ‚Äì O campo de erro pode aparecer apenas ap√≥s o submit do formul√°rio ou quando a valida√ß√£o client‚Äëside dispara.
2. **Sele√ß√£o incorreta** ‚Äì O ID pode estar diferente, ou a mensagem pode estar dentro de um outro elemento (ex.: `<span>` ou `<div>`).
3. **Timing problem** ‚Äì O teste pode estar verificando antes que a mensagem de erro seja inserida no DOM (ex.: falta de `await page.waitForSelector()`).
4. **Bug no formul√°rio** ‚Äì A valida√ß√£o de telefone pode n√£o estar sendo acionada por causa de um bug ou de dados que n√£o s√£o considerados ‚Äúvazios‚Äù pelo front‚Äëend (ex.: espa√ßos em branco).

---

## 3. Sugest√µes de corre√ß√£o

### 3.1. Corrigindo o teste de login inv√°lido

| Passo | A√ß√£o | Por qu√™ |
|-------|------|---------|
| 1 | **Verifique a mensagem real** | Abra o aplicativo no mesmo ambiente usado pelo teste e realize um login inv√°lido. Observe a mensagem exibida em `.error`. |
| 2 | **Atualize o esperado** | Se a mensagem for realmente ‚ÄúThe username and password could not be verified.‚Äù, altere o teste para usar essa string (ou um trecho comum a ambas, se a mensagem mudar). |
| 3 | **Use `toHaveText` para correspond√™ncia exata** | Se voc√™ quer garantir que o texto completo seja exatamente o esperado, troque `toContainText` por `toHaveText`. |
| 4 | **Considere usar vari√°veis globais** | Se diferentes ambientes exibem mensagens distintas, crie uma vari√°vel de configura√ß√£o (`env.LOGIN_ERROR_MSG`) e use-a no teste. |
| 5 | **Adicione um screenshot no erro** | `await page.screenshot({ path: 'screenshots/login-error.png' })` ‚Äì ajuda a validar visualmente a mensagem e a localiza√ß√£o. |
| 6 | **Reavalie o fluxo de erro** | Se a mensagem ‚ÄúAn internal error‚Ä¶‚Äù for a inten√ß√£o correta, verifique por que ela n√£o est√° sendo exibida: pode ser um bug no backend ou no front‚Äëend. Corrija a origem do erro e, depois, atualize o teste. |

#### Exemplo de c√≥digo atualizado

```javascript
test('Login inv√°lido deve exibir mensagem de erro', async ({ page }) => {
  await page.goto('/login');
  await page.fill('#username', 'user');
  await page.fill('#password', 'wrongpass');
  await page.click('button[type="submit"]');

  // Espera que o erro seja exibido
  const errorLocator = page.locator('.error');
  await expect(errorLocator).toHaveText(
    'The username and password could not be verified.'
  );
});
```

### 3.2. Corrigindo o teste de telefone vazio

| Passo | A√ß√£o | Por qu√™ |
|-------|------|---------|
| 1 | **Confirme o seletor** | No console do browser, inspecione o elemento que aparece quando a valida√ß√£o falha. Pode ser `<span id="phone-error">Phone is required.</span>` ou algo similar. Ajuste o selector (`'#phone-error'` ou `'.phone-error'`). |
| 2 | **Assegure a exibi√ß√£o do erro** | Adicione um `await page.waitForSelector('#phone-error', { timeout: 8000 })` antes de fazer a asser√ß√£o. Isso evita que o teste falhe por timing. |
| 3 | **Verifique o submit** | Certifique‚Äëse de que o teste est√° submetendo o formul√°rio (ex.: `await page.click('button[type="submit"]')`) antes de esperar o erro. |
| 4 | **Valida√ß√£o de campo vazio** | Se o campo aceita ‚Äú ‚Äù (espa√ßos), limpe antes de enviar: `await page.fill('#phone', '');`. |
| 5 | **Use `toHaveText`** | Para garantir exatid√£o: `await expect(page.locator('#phone-error')).toHaveText('Phone is required.');` |
| 6 | **Debug visual** | Tire um screenshot no momento que a falha acontece: `await page.screenshot({ path: 'screenshots/phone-error.png' })`. |
| 7 | **Reveja a l√≥gica de valida√ß√£o** | Se o erro n√£o aparece, o front‚Äëend pode n√£o ter a valida√ß√£o habilitada. Cheque o script que executa a valida√ß√£o. |

#### Exemplo de c√≥digo atualizado

```javascript
test('Usu√°rio deve atualizar telefone com campo vazio', async ({ page }) => {
  await page.goto('/profile');
  // Limpa o campo de telefone
  await page.fill('#phone', '');

  // Submete o formul√°rio
  await page.click('button[type="submit"]');

  // Espera a mensagem de erro
  const errorLocator = page.locator('#phone-error');
  await expect(errorLocator).toBeVisible({ timeout: 8000 });

  // Verifica o texto exato
  await expect(errorLocator).toHaveText('Phone is required.');
});
```

---

## 4. Boas pr√°ticas adicionais

| Tema | Dica |
|------|------|
| **Mensagens de erro** | Mantenha os textos de erro em arquivos de configura√ß√£o (ex.: `i18n`) e referencie-as nos testes. |
| **Timeouts** | Ajuste o timeout de forma que seja suficiente para o DOM atualizar, mas n√£o muito alto para n√£o mascarar bugs. |
| **Screenshot e trace** | Use `await page.screenshot()` e `await page.context().tracing.start()` para capturar a execu√ß√£o completa. |
| **Assertivas** | Prefira `toHaveText` a `toContainText` quando precisar de exatid√£o. Use `toContainText` para verifica√ß√µes parciais. |
| **Separa√ß√£o de responsabilidades** | Se o teste envolve l√≥gica de neg√≥cio (ex.: verificar que um campo n√£o aceita valores nulos), crie testes de unidade em conjunto com os de UI. |

Seguindo essas recomenda√ß√µes, os testes ficar√£o mais confi√°veis, f√°ceis de manter e mais pr√≥ximos da experi√™ncia real do usu√°rio. üöÄ