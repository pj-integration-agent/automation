## 1. Testes que falharam  

| Horário | Descrição do teste | Identificador (caso houver) |
|---------|--------------------|------------------------------|
| 13:05:09 | **Login inválido falhou** | `Login inválido` |
| 13:05:10 | **Usuário deve atualizar telefone com campo vazio falhou** | `Atualizar telefone - campo vazio` |

---

## 2. Motivo de cada falha  

### 2.1. Login inválido falhou  

1. **Mensagem esperada vs. mensagem real**  
   - **Esperado**: `"An internal error has occurred and has been logged."`  
   - **Real**: `<p class="error">The username and password could not be verified.</p>`

   O teste procurou por uma mensagem genérica de erro interno, mas a aplicação retornou uma mensagem de *autenticação inválida*.  
2. **Elemento encontrado, porém com conteúdo inesperado**  
   O `locator('.error')` conseguiu localizar o elemento `<p class="error">`, mas o conteúdo não combinava com a substring que o teste esperava.  
3. **Timeout**  
   O Playwright tentou esperar 5 s e não encontrou a substring esperada, então o teste falhou com `element(s) not found`.

### 2.2. Usuário deve atualizar telefone com campo vazio falhou  

1. **Elemento não encontrado**  
   O seletor XPath `'//*[@id="phone-error"]'` não retornou nenhum nó no DOM.  
   - Possíveis causas:  
     - O elemento realmente não existe (por exemplo, o erro não é exibido com um `id="phone-error"`).  
     - O erro só aparece após um evento (ex.: submit), mas o teste não o disparou corretamente.  
     - O erro está dentro de um iframe, Shadow DOM ou outro contexto que não está sendo acessado.  
     - O seletor está incorreto (typo ou atributo diferente).  
2. **Timeout**  
   Como o elemento não apareceu dentro de 5 s, o Playwright sinalizou timeout com “element(s) not found”.

---

## 3. Sugestões de correção  

### 3.1. Login inválido falhou  

| Estratégia | Como fazer | Por quê |
|------------|------------|---------|
| **Ajustar a string esperada** | Altere o teste para verificar a mensagem real:<br>`await expect(locator('.error')).toContainText('The username and password could not be verified.');` | O teste deve refletir o comportamento real da aplicação. |
| **Usar `toHaveText` para comparação exata** | `await expect(locator('.error')).toHaveText('The username and password could não ser verificado.');` | Garante que nenhuma parte extra apareça. |
| **Adicionar screenshot e console log** | `await page.screenshot({ path: 'login-error.png' }); console.log(await locator('.error').innerText());` | Facilita o diagnóstico de mensagens dinâmicas. |
| **Verificar ambiente de teste** | Assegure‑se que o banco de dados ou o mock usado realmente gera a mensagem de “login inválido”. | Se a mensagem mudou por migração ou configuração, o teste precisa ser atualizado. |
| **Isolar o teste de dependências** | Se o erro interno pode ocorrer por falha de servidor, crie um mock para garantir que o teste sempre receba a mensagem de “login inválido”. | Evita flutuações externas. |

### 3.2. Usuário deve atualizar telefone com campo vazio falhou  

| Estratégia | Como fazer | Por quê |
|------------|------------|---------|
| **Verificar o seletor** | Abra o inspetor no navegador, confirme se há um elemento com `id="phone-error"` ou outro identificador. Se não houver, atualize o seletor no teste: `await expect(locator('#phone-error')).toBeVisible();` ou use uma classe/atributo que exista. | Um seletor incorreto é a causa mais comum de “element not found”. |
| **Aguardar visibilidade** | `await expect(locator('#phone-error')).toBeVisible({ timeout: 8000 });` | Se o erro aparece depois de uma animação ou tempo de processamento, aumente o timeout ou aguarde a visibilidade. |
| **Disparar o evento de validação** | Certifique-se de que o teste limpa o campo de telefone, clica em outro campo ou submete o formulário antes de verificar o erro: `<button type="submit"></button>` ou `await page.keyboard.press('Enter');`. | O erro só é gerado após um evento, caso contrário não aparece. |
| **Checar se o erro está dentro de iframe/Shadow DOM** | Se o formulário estiver dentro de um iframe, use `const frame = page.frame({ url: /.*iframe/ }); const error = frame.locator('#phone-error');` | Se o contexto não for o `page`, o locator padrão não encontrará nada. |
| **Usar `toContainText` vs `toHaveText`** | Se a mensagem pode conter espaços extras, `toContainText` pode ser mais permissivo. | Dependendo do caso, escolha o matcher que melhor reflete o comportamento esperado. |
| **Adicionar log de console** | `console.log(await page.content());` | Permite ver o DOM completo no momento da falha. |

---

## 4. Checklist rápido para evitar falhas futuras  

1. **Documentar mensagens de erro** – Mantenha um arquivo de “strings de UI” que contenha todas as mensagens de erro, de forma que os testes possam referenciá‑las por chave.  
2. **Centralizar seletores** – Crie um arquivo de locators (por exemplo, `locators.js`) e use esses valores em todos os testes. Assim, quando o seletor mudar, apenas um ponto de manutenção é necessário.  
3. **Esperas explícitas** – Prefira `toBeVisible`, `toHaveText`, `toBeDisabled`, etc., em vez de esperar por timeout genérico.  
4. **Screenshots em caso de falha** – Configure o Playwright para tirar screenshots automaticamente (`expect(...).toHaveScreenshot()` ou `page.screenshot()`).  
5. **Testes idempotentes** – Certifique‑se de que cada teste limpa ou reinicializa o estado (ex.: `await page.reload();` ou `await page.goto('/')` antes do início).  

Aplicando essas correções e boas práticas, os testes se tornarão mais confiáveis e mais fáceis de manter.