## 1. Testes que falharam  

| Nome do teste | Horário | Status |
|---------------|---------|--------|
| **Login inválido** | 16:51:24.828 | **Falhou** |
| **Usuário deve atualizar telefone com campo vazio** | 16:51:26.691 | **Falhou** |

## 2. Motivo de cada falha  

### 2.1 Login inválido  
- **Assertivo que falhou**:  
  ```javascript
  await expect(locator('.error')).toContainText(
      'An internal error has occurred and has been logged.'
  )
  ```
- **Mensagem real na página**:  
  ```html
  <p class="error">The username and password could not be verified.</p>
  ```
- **Por que falhou?**  
  - O texto esperado na asserção (“An internal error …”) não corresponde ao texto real exibido (“The username …”).  
  - Provavelmente o teste foi escrito com base em um cenário que retornava um *internal error*, mas o ambiente de teste está retornando um erro de credenciais inválidas.  
  - O timeout (5000 ms) não é o problema; a falha ocorre imediatamente porque o conteúdo já existe, apenas está diferente.

### 2.2 Usuário deve atualizar telefone com campo vazio  
- **Assertivo que falhou**:  
  ```javascript
  await expect(locator('//*[@id="phone-error"]')).toContainText(
      'Phone is required.'
  )
  ```
- **Resultado**:  
  - O Playwright não encontrou nenhum elemento com o seletor XPath `//*[@id="phone-error"]` dentro dos 5 s.  
- **Por que falhou?**  
  1. **Seleção errada** – O elemento de erro pode não ter o `id="phone-error"`.  
  2. **Elemento não visível** – O erro pode aparecer somente após um evento (por exemplo, blur ou submit) que não foi disparado no teste.  
  3. **Carregamento assíncrono** – A mensagem de erro pode ser renderizada depois de uma requisição AJAX que não terminou no tempo de espera.  
  4. **Erro no teste** – O nome “Phone is required.” pode estar em outro idioma ou com ortografia diferente (`Phone number is required.`).  

## 3. Sugestões de correção  

### 3.1 Corrigindo o teste de “Login inválido”

| Estratégia | Como aplicar |
|------------|--------------|
| **Ajustar o texto esperado** | Verifique o texto real que a aplicação mostra para credenciais inválidas. Atualize a asserção para usar esse texto exato, ou para um *partial match* que seja robusto: <br>`await expect(locator('.error')).toContainText(/verified/i);` |
| **Usar `toHaveText` em vez de `toContainText`** | Se o elemento pode ter outros textos em torno da mensagem, use <br>`await expect(locator('.error')).toHaveText('The username and password could not be verified.');` |
| **Adicionar `waitForSelector` antes da asserção** | Garantir que o erro realmente apareceu: <br>`await page.waitForSelector('.error', { state: 'visible', timeout: 7000 });` |
| **Revisar ambiente de teste** | Se o cenário de erro interno foi o objetivo original, verifique se o backend está configurado para lançar esse erro em vez de credenciais inválidas. |

**Exemplo de código corrigido**  
```javascript
await page.goto('/login');
await page.fill('#username', 'wrong');
await page.fill('#password', 'wrong');
await page.click('#submit');

await page.waitForSelector('.error', { state: 'visible', timeout: 7000 });

await expect(page.locator('.error')).toHaveText(
  'The username and password could not be verified.'
);
```

### 3.2 Corrigindo o teste de “Usuário deve atualizar telefone com campo vazio”

| Estratégia | Como aplicar |
|------------|--------------|
| **Verificar o seletor** | Abra a aplicação em modo devtools e confirme se o erro de telefone tem realmente `id="phone-error"`. Se não, use outro seletor (por exemplo, `[data-testid="phone-error"]` ou `text=Phone is required`). |
| **Forçar o evento de validação** | Se a mensagem aparece apenas após blur ou submit, faça isso explicitamente:<br>`await page.fill('#phone', '');`<br>`await page.click('#save');` |
| **Aumentar o timeout** | Se a mensagem leva um tempo para ser renderizada, aumente o timeout: <br>`await expect(locator('[data-testid="phone-error"]')).toContainText('Phone is required.', { timeout: 10000 });` |
| **Usar regex ou `toContainText`** | Se houver variações (por ex.: “Phone number is required.”) use regex: <br>`await expect(locator('[data-testid="phone-error"]')).toContainText(/Phone.*required/i);` |
| **Adicionar `waitForSelector`** | Garanta que o elemento exista antes da asserção: <br>`await page.waitForSelector('#phone-error', { state: 'visible', timeout: 7000 });` |

**Exemplo de código corrigido**  
```javascript
await page.goto('/profile/phone');
await page.fill('#phone', '');          // deixa o campo vazio
await page.click('#save');              // dispara a validação

// Espera que a mensagem de erro apareça
await page.waitForSelector('#phone-error', { state: 'visible', timeout: 7000 });

await expect(page.locator('#phone-error')).toContainText(
  'Phone is required.'
);
```

## 4. Dicas gerais para evitar falhas semelhantes

1. **Documentar mensagens de erro** – Mantenha uma tabela de todos os textos de erro em cada ambiente (dev, staging, prod).  
2. **Uso de atributos de teste** – Quando possível, adicione `data-testid` aos elementos de UI que serão usados em testes. Isso evita dependência de classes/IDs que mudam com frequência.  
3. **Teste de regressão** – Adicione snapshots (`toMatchSnapshot`) para mensagens de erro quando forem críticos.  
4. **Logs de erro detalhados** – Em caso de falha, capture `page.content()` e `page.screenshot()` para analisar visualmente o que realmente aconteceu.  
5. **Cobertura de cenários** – Verifique se o teste realmente cobre o caso que o negócio quer testar. Se o teste esperava “internal error”, mas o fluxo atual deve exibir “credenciais inválidas”, então o teste está desatualizado.

Com essas correções e boas práticas, os testes deverão passar com sucesso e refletir corretamente o comportamento da aplicação.