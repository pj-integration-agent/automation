## 1. Testes que falharam

| # | Nome do teste | Log de falha |
|---|---------------|--------------|
| 1 | **Login inválido falhou** | `expect(locator('.error')).toContainText(expected) failed` |
| 2 | **Usuário deve atualizar telefone com campo vazio falhou** | `expect(locator('//*[@id="phone-error"]')).toContainText(expected)` falhou e *element(s) not found* |

---

## 2. Motivo de cada falha

### 2.1 Login inválido falhou  
- **O que aconteceu**  
  - O teste esperava que o elemento `<p class="error">` exibisse a mensagem **“An internal error has occurred and has been logged.”**  
  - O texto real que apareceu na página foi **“The username and password could not be verified.”**  
- **Por que falhou**  
  - **Desalinhamento entre a expectativa do teste e a mensagem real** que a aplicação retorna para o cenário de login inválido.  
  - Provavelmente a aplicação mudou a mensagem (ou a mensagem original está incorreta no teste).  
  - O erro não está relacionado a timing, pois o elemento apareceu rapidamente (`7 × locator resolved`), mas a string não combinou.

### 2.2 Usuário deve atualizar telefone com campo vazio falhou  
- **O que aconteceu**  
  - O teste procurou um elemento com o *XPath* `//*[@id="phone-error"]`.  
  - O Playwright não encontrou nenhum elemento correspondente dentro do timeout de 5 s e retornou *“element(s) not found”*.  
  - Mesmo que o elemento estivesse presente, a mensagem esperada “Phone is required.” não seria encontrada porque o elemento não foi localizado.  
- **Por que falhou**  
  1. **Seletor frágil ou incorreto** – O XPath pode estar errado, ou a estrutura do DOM mudou.  
  2. **Erro de validação não acionado** – Pode ser que o campo de telefone não tenha sido deixado em branco corretamente, ou o botão de submissão não dispare a validação.  
  3. **Timing inadequado** – O elemento pode aparecer após mais de 5 s (por ex., após uma chamada API).  

---

## 3. Sugestões de correção

### 3.1 Corrigir o teste de login inválido

| Passo | Como fazer | Por que funciona |
|-------|------------|------------------|
| a. | **Verificar a mensagem real** – Abra a aplicação em modo de depuração ou faça um teste manual e confirme a mensagem exibida ao usar credenciais inválidas. | Garante que o teste reflita o comportamento atual da aplicação. |
| b. | **Atualizar a expectativa** – Troque a string esperada no `expect(...).toContainText()` para “The username and password could not be verified.” ou para uma substring que realmente apareça (ex.: “username and password could not be verified”). | A string de comparação agora corresponde ao texto real. |
| c. | **Usar `toHaveText`** em vez de `toContainText` se quiser validar exatamente a mensagem, ou usar `toContainText` com substring curta (ex.: “verified” ou “could not be”). | Reduz a chance de falsos positivos/negativos. |
| d. | **Adicionar `debug()` antes da expectativa** (opcional) | Permite inspecionar a página e confirmar que o elemento está correto. |

#### Exemplo de código corrigido

```ts
await page.fill('#username', 'wrongUser');
await page.fill('#password', 'wrongPass');
await page.click('#loginBtn');

await expect(page.locator('.error')).toContainText(
  'The username and password could not be verified.'
);
```

---

### 3.2 Corrigir o teste de telefone vazio

| Passo | Como fazer | Por que funciona |
|-------|------------|------------------|
| a. | **Revisar o seletor** – Em vez de XPath, use o seletor CSS com ID: `page.locator('#phone-error')`. | CSS é mais rápido e menos propenso a falhas por alterações de estrutura. |
| b. | **Verificar se o elemento realmente existe** – Execute o teste manualmente ou use `await page.locator('#phone-error').count()` para confirmar se o elemento aparece. | Garante que a validação está sendo disparada. |
| c. | **Disparar a validação corretamente** – Se o campo de telefone fica vazio automaticamente, certifique‑se de que o formulário é submetido (ex.: `await page.click('#submitBtn')`). | Garante que a mensagem de erro é gerada. |
| d. | **Aumentar o timeout (se necessário)** – Se a mensagem aparecer após um tempo de processamento, use `await expect(page.locator('#phone-error')).toContainText('Phone is required.', { timeout: 8000 });`. | Evita falhas de timing. |
| e. | **Adicionar `waitForSelector`** opcionalmente: `await page.waitForSelector('#phone-error', { state: 'visible', timeout: 8000 });` | Força o Playwright a aguardar a presença do elemento. |

#### Exemplo de código corrigido

```ts
await page.fill('#phone', ''); // deixa vazio
await page.click('#updateBtn'); // dispara validação

await expect(page.locator('#phone-error')).toContainText(
  'Phone is required.'
);
```

---

## 4. Boas práticas gerais

1. **Evite XPaths** – Use seletores CSS ou atributos `data-qa`/`data-test` específicos para testes.  
2. **Use mensagens curtas** – Quando a mensagem pode mudar de forma, compare substrings ou use regexes.  
3. **Aumente a visibilidade de erros** – Ao falhar, faça `page.screenshot()` ou `page.pdf()` para capturar o estado da UI.  
4. **Isolar as mudanças de UI** – Mantenha as mensagens de erro em um arquivo de recursos (JSON, i18n) e importe no teste; assim, se a mensagem mudar, basta atualizar o recurso.  
5. **Configurar timeout global** – Em `playwright.config.ts`, ajuste o `timeout` padrão se a aplicação for lenta; isso evita falhas de timing em testes não críticos.  

Com essas alterações o relatório de falhas deve desaparecer e os testes ficarão mais robustos e fáceis de manter. Boa execução!