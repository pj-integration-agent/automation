**Resumo do que aconteceu**

| # | Teste | Status | Motivo da falha | O que fazer (solução) |
|---|-------|--------|-----------------|-----------------------|
| 1 | **Login inválido falhou** | ❌ | O teste esperava a mensagem *“An internal error has occurred and has been logged.”* mas a página retornou *“The username and password could not be verified.”* | Atualizar a expectativa para a mensagem real ou mudar o fluxo do teste para gerar o erro interno esperado. |
| 2 | **Usuário deve atualizar telefone com campo vazio falhou** | ❌ | O seletor `//*[@id="phone-error"]` não encontrou nenhum elemento dentro dos 5 s. | Garantir que o erro seja realmente exibido (por ex., clicando em “Salvar” depois de deixar o campo vazio) e/ou usar um seletor mais robusto (id, classe, texto). |

Abaixo detalhamos cada falha e sugestões de correção.

---

## 1. Login inválido falhou

### O que aconteceu
```
Expected substring: "An internal error has occurred and has been logg…"
Received string:    "The username and password could not be verified."
```
O `expect(locator('.error')).toContainText(...)` encontrou o elemento `<p class="error">The username and password could not be verified.</p>` e o texto não bateu com o esperado.

### Possíveis causas
| Causa | Por que pode ter acontecido |
|-------|----------------------------|
| **Mudança na mensagem de erro** | A aplicação foi atualizada e agora mostra uma mensagem de validação de credenciais em vez da mensagem de erro interno. |
| **Teste escrito para outro ambiente** | O ambiente de teste pode ter um comportamento diferente (por ex., sandbox vs. produção). |
| **Erro de digitação no teste** | O texto esperado foi copiado errado ou inclui espaços/sintaxe de escape que não existem na página. |

### Como corrigir
1. **Verifique a mensagem real na UI**  
   Abra o aplicativo em modo de teste e tente fazer login com credenciais inválidas. Confirme a mensagem que aparece.

2. **Atualize a expectativa**  
   ```ts
   await expect(page.locator('.error')).toContainText(
     'The username and password could not be verified.'
   );
   ```

   Se a mensagem pode mudar (ex.: traduções), use `toHaveText` com expressões regulares ou `toContainText` com parte do texto:
   ```ts
   await expect(page.locator('.error')).toContainText(/username and password/);
   ```

3. **Se a mensagem de erro interno for o que o teste deveria validar**  
   - Garanta que o fluxo realmente gere esse erro (por ex., forçar um erro no backend ou simular um timeout).  
   - Caso a aplicação não esteja configurada para exibir o erro interno em ambiente de teste, considere mockar a resposta da API ou criar um cenário de teste que provoque esse erro.

4. **Documente o motivo da alteração**  
   Adicione comentários no teste explicando por que a expectativa mudou (ex.: “mensagem atualizada após correção de bug #123”). Isso evita que a mudança volte a ser “incorreta” no futuro.

---

## 2. Usuário deve atualizar telefone com campo vazio falhou

### O que aconteceu
```
Error: element(s) not found
Locator: locator('//*[@id="phone-error"]')
```
O Playwright tentou localizar um elemento com **XPath** `//*[@id="phone-error"]` mas não encontrou nada dentro de 5 s.

### Possíveis causas
| Causa | Por que pode ter acontecido |
|-------|-----------------------------|
| **Seleto errado** | O elemento pode ter outro id (`phoneError`, `phone_error`, etc.) ou pode estar dentro de um componente dinâmico que ainda não foi renderizado. |
| **Erro não aparece até submeter o formulário** | Se o campo está vazio, o erro só é gerado após clicar em “Salvar” ou “Atualizar”. O teste pode estar verificando o erro antes de disparar a validação. |
| **Erro aparece em um elemento diferente** | Pode ser que o erro seja exibido em um `<span>` próximo ao `<input>` em vez de um `<div>` com id `phone-error`. |
| **Problema de tempo de espera** | 5 s pode ser curto se a página usa animações ou tem latência. |

### Como corrigir
1. **Inspecione o DOM**  
   Abra o aplicativo, deixe o campo de telefone vazio e submeta. Use a DevTools para ver onde o erro aparece (qual tag, id, classe, texto).

2. **Escolha um seletor mais confiável**  
   - **Por id** (se existir): `await expect(page.locator('#phone-error')).toHaveText('Phone is required.');`
   - **Por texto** (caso seja um `<p>` ou `<span>`): `await expect(page.locator('text=Phone is required.')).toBeVisible();`
   - **Por relação com o input**:  
     ```ts
     await expect(page.locator('label[for="phone"] + .error')).toHaveText('Phone is required.');
     ```
   - **XPath** pode ser mantido, mas certifique‑se de que o caminho está correto:  
     ```ts
     await expect(page.locator('//*[@id="phone-error"]')).toHaveText('Phone is required.');
     ```

3. **Garanta que a validação seja disparada antes da asserção**  
   ```ts
   await page.fill('#phone', '');      // deixa vazio
   await page.click('#update-button'); // submete
   await expect(page.locator('#phone-error')).toHaveText('Phone is required.');
   ```

4. **Aumente o timeout se necessário**  
   Se o erro for exibido depois de uma animação ou chamada AJAX, aumente o timeout ou use `waitForSelector`:
   ```ts
   await page.waitForSelector('#phone-error', { state: 'visible', timeout: 8000 });
   ```

5. **Teste de regressão**  
   Após corrigir, rode o teste isoladamente para garantir que ele passa e que não há side‑effects em outros testes.

---

## Resumo das correções sugeridas

| Teste | Correção prática (código) |
|-------|---------------------------|
| **Login inválido** | ```ts await expect(page.locator('.error')).toContainText('The username and password could not be verified.'); ``` |
| **Telefone vazio** | 1. Submeta o formulário depois de deixar o campo vazio. <br>2. Use seletor confiável: `await expect(page.locator('#phone-error')).toHaveText('Phone is required.');` |
| **Timeout** | Se necessário, aumente o timeout: `await expect(locator).toHaveText(..., { timeout: 8000 });` |

Ao aplicar essas alterações, os testes devem passar e refletir corretamente o comportamento real da aplicação. Certifique‑se de manter os comentários nos testes explicando o raciocínio por trás das escolhas de seletor e mensagem esperada. Isso ajudará quem vier depois a entender rapidamente o que cada teste verifica e por que ele foi alterado.