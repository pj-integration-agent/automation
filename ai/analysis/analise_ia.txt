## 1. Testes que falharam

| # | Descrição do teste | Status |
|---|---------------------|--------|
| 1 | **Login inválido falhou** | ❌ Falhou |
| 2 | **Usuário deve atualizar telefone com campo vazio falhou** | ❌ Falhou |

---

## 2. Motivo de cada falha

### 2.1 Login inválido falhou

| Item | Informação |
|------|------------|
| **Locator** | `locator('.error')` (um `<p class="error">...</p>` aparece na tela) |
| **Texto esperado** | `"An internal error has occurred and has been logged."` |
| **Texto recebido** | `"The username and password could not be verified."` |
| **Timeout** | 5 s |
| **Erro** | `expect(...).toContainText(...) failed` – o texto esperado não está presente no elemento. |

**Resumo:**  
O teste está verificando que, ao tentar fazer login com credenciais inválidas, a aplicação deve exibir a mensagem *“An internal error has occurred and has been logged.”*. Entretanto, a aplicação devolveu a mensagem *“The username and password could not be verified.”* – duas mensagens diferentes. O `toContainText` falha porque o substring esperado não aparece no elemento.

---

### 2.2 Usuário deve atualizar telefone com campo vazio falhou

| Item | Informação |
|------|------------|
| **Locator** | `locator('//*[@id="phone-error"]')` (XPath) |
| **Texto esperado** | `"Phone is required."` |
| **Timeout** | 5 s |
| **Erro** | `element(s) not found` – o elemento com `id="phone-error"` não apareceu na página dentro do tempo limite. |

**Resumo:**  
O teste espera que, ao submeter o formulário de atualização de telefone com o campo em branco, apareça uma mensagem de erro com o texto *“Phone is required.”* O Playwright não conseguiu encontrar o elemento com o id informado. Isso pode ocorrer porque:

1. O id do elemento de erro está diferente (por ex.: `phone-error` vs `phoneError`).
2. O elemento não está sendo criado até que o formulário seja submetido (talvez o submit não esteja sendo acionado corretamente).
3. O formulário usa validação do lado do cliente que só dispara após foco/blur ou após o botão “Salvar” ser clicado, e isso não aconteceu no teste.
4. A aplicação pode ter alterado a estrutura HTML, removendo ou renomeando o elemento de erro.

---

## 3. Sugestões de correção

### 3.1 Corrigindo o teste de login inválido

| Estratégia | Como aplicar |
|-------------|--------------|
| **Atualizar o texto esperado** | Se a mensagem correta é “The username and password could not be verified.”, basta alterar a string no `expect` para refletir a nova mensagem. |
| **Tornar a verificação mais flexível** | Use `toContainText` com substring comum ou regex, ex.: `expect(page.locator('.error')).toContainText(/username and password/i)` – assim o teste continuará válido mesmo que a mensagem varie em detalhes. |
| **Verificar se o status HTTP ou código de erro está correto** | Se a aplicação deveria retornar 401 ou 500, adicione um `expect(page).toHaveURL(/login/).and.toHaveStatus(401)` (ou equivalente). |
| **Revisar se o teste realmente deve checar essa mensagem** | Caso essa mensagem seja de erro interno (produtos de produção normalmente não exibem internals para usuários), considere mudar a expectativa para a mensagem de *“Credenciais inválidas”* ou remover a verificação. |

#### Exemplo de código corrigido

```ts
// Se a mensagem mudou
await expect(page.locator('.error')).toContainText('The username and password could not be verified.');

// Ou com regex mais permissivo
await expect(page.locator('.error')).toContainText(/username and password/i);
```

---

### 3.2 Corrigindo o teste de atualização de telefone

| Passo | Detalhe |
|-------|---------|
| **1. Verificar o id correto** | Abra o DOM (DevTools → Elements) após submeter o formulário vazio e procure pelo elemento de erro. Note se o id realmente é `phone-error` ou algo parecido (`phone-error-msg`, `#phoneError`, etc.). Se for diferente, atualize o locator: `locator('#phoneError')` ou `locator('p.phone-error')`. |
| **2. Garantir que a submissão ocorre** | Confirme que o teste está clicando no botão “Salvar” ou “Atualizar”. Se o botão for `<button type="submit">`, usar `await page.getByRole('button', { name: 'Salvar' }).click();`. Se for um evento custom, chame a função correta. |
| **3. Esperar o DOM mudar** | Em vez de depender de `timeout: 5000`, use `await expect(locator).toBeVisible()` ou `await page.waitForSelector('#phone-error', { state: 'visible', timeout: 8000 })`. Isso garante que o Playwright espere a mensagem de erro aparecer. |
| **4. Usar XPath corretamente** | Se você realmente precisa usar XPath, verifique se está completo: `//p[@id="phone-error"]` ou `//*[@id="phone-error"]`. No entanto, CSS é mais legível: `locator('#phone-error')`. |
| **5. Validar que o elemento existe antes do texto** | Adicione `await expect(locator).toBeVisible()` antes de `toContainText`. Se o elemento não existir, o teste falhará de forma mais clara. |
| **6. Verificar validação de formulário** | Se o formulário usa HTML5 (`required` no input), o navegador pode impedir a submissão. Certifique-se de que o teste força a submissão (`await page.getByRole('button').click()`) e depois verifica a mensagem. |

#### Exemplo de código corrigido

```ts
// 1. Submeter o formulário com telefone vazio
await page.getByLabel('Phone').fill('');
await page.getByRole('button', { name: 'Salvar' }).click();

// 2. Esperar o erro aparecer
const phoneError = page.locator('#phone-error');  // ou outro seletor correto
await expect(phoneError).toBeVisible({ timeout: 8000 });

// 3. Verificar a mensagem
await expect(phoneError).toContainText('Phone is required.');
```

---

## 4. Dicas de boas práticas

1. **Use seletores semântico** (`getByRole`, `getByLabel`, `getByText`) quando possível – são mais robustos a mudanças de CSS e IDs.
2. **Mantenha textos de erro centralizados** – se a aplicação tem um arquivo de mensagens ou i18n, use valores dessa fonte nos testes, não strings hard‑coded.
3. **Evite hard‑coded timeouts** – prefira esperar por estado visível ou existências de elementos; isso deixa os testes mais rápidos e confiáveis.
4. **Adicione logs detalhados** – ao falhar, o Playwright já imprime o conteúdo do elemento. Se necessário, faça `console.log(page.locator('.error').textContent())` antes da verificação para entender o que realmente aparece.
5. **Revise a suíte regularmente** – quando o UI muda, atualize os testes antes de considerar a falha crítica.

---

### Conclusão

- **Login inválido**: a mensagem de erro esperada não corresponde à atual – atualize a expectativa ou torne‑a mais flexível.
- **Atualizar telefone vazio**: o elemento de erro não aparece – verifique o seletor, garanta que a submissão ocorre e espere pela visibilidade.

Aplique as correções acima, execute a suíte novamente e verifique se os testes passam. Boa sorte!