## 1. Quais testes falharam

| # | Nome do teste | Status |
|---|---------------|--------|
| 1 | **Login inválido falhou** | **Falhou** |
| 2 | **Usuário deve atualizar telefone com sucesso falhou** | **Falhou** |
| 3 | **Usuário deve atualizar telefone com campo vazio falhou** | **Falhou** |

> **Resumo:** Todos os testes listados no log falharam.

---

## 2. Motivo de cada falha

### 1. `Login inválido falhou`

- **Erro:** `expect(locator('.error')).toContainText(expected) failed`
- **Detalhe:** O test se baseava no erro interno `"An internal error has ocorrido e foi registrado."`.  
- **Situação real:** O elemento `<p class="error">` continha o texto **"The username and password could not be verified."**  
- **Conclusão:** O teste esperava uma mensagem de erro diferente (interno do sistema) do que o sistema retornou (erro de autenticação). Provavelmente o fluxo de login mudou ou o seletor mudou.

### 2. `Usuário deve atualizar telefone com sucesso falhou`

- **Erro:** `Test timeout of 10000ms exceeded.`
- **Detalhe:** O teste esperava que a página concluísse a operação de atualização dentro de 10 s, mas a execução excedeu esse limite.  
- **Causas possíveis:**
  1. **Rede lenta / servidor lento** – a requisição de atualização pode demorar mais que 10 s.
  2. **Lógica de espera insuficiente** – o teste pode estar aguardando um elemento que nunca aparece ou que aparece em outro tempo.
  3. **Bug no fluxo de atualização** – pode estar travado em um loop ou em erro de validação que não foi tratado.

### 3. `Usuário deve atualizar telefone com campo vazio falhou`

- **Erro:** `expect(locator('//*[@id="phone-error"]')).toContainText(expected) failed`
- **Detalhe:** O teste esperava que o elemento com `id="phone-error"` mostrasse o texto `"Phone is required."`, mas não encontrou nem o elemento nem o texto dentro de 5 s.  
- **Causas possíveis:**
  1. O campo vazio pode não disparar a mensagem de erro (falha de validação).
  2. O seletor `//*[@id="phone-error"]` pode estar incorreto ou o erro pode aparecer em um outro local (por exemplo, um toast, modal ou mensagem inline diferente).
  3. O teste pode estar executado antes que o campo seja realmente focado ou que a validação seja disparada.

---

## 3. Sugestões de correção

| # | Recomendação | Como implementar |
|---|--------------|------------------|
| **1** | **Atualizar o texto esperado** | 1. Verifique a tela de login real (ou a documentação da API) para o texto exato de erro que deve aparecer quando o usuário fornece credenciais inválidas.  <br>2. Modifique a expectativa do teste para usar esse texto exato: `await expect(page.locator('.error')).toContainText('The username and password could not be verified.');`  <br>3. Se o texto pode mudar dinamicamente (ex.: incluir “try again in X seconds”), use uma regex ou `toContainText` com substring. |
| **1** | **Usar o seletor correto** | Caso a classe `error` não seja mais usada, encontre o seletor atual (ex.: `div.alert.alert-danger`) e ajuste o `locator('.error')` para o novo seletor. |
| **2** | **Aumentar ou tornar dinâmico o timeout** | 1. Se a atualização costuma demorar mais de 10 s, aumente o timeout no comando `await expect(page.locator(...)).toHaveText(..., { timeout: 20000 });`  <br>2. Use `page.waitForResponse` ou `page.waitForURL` para esperar o término da requisição em vez de apenas o aparecimento de um elemento. |
| **2** | **Adicionar uma verificação de resposta da API** | Se a atualização envolve uma chamada REST, adicione: `await page.waitForResponse(response => response.url().includes('/api/phone') && response.status() === 200);` antes de verificar o UI. |
| **2** | **Rever lógica de validação** | Se o fluxo de atualização não exibe nenhuma mudança de UI, verifique se o campo está realmente sendo enviado (use `page.$eval('#phone', el => el.value)` antes de clicar no botão). |
| **3** | **Confirmar onde o erro aparece** | 1. Abra o aplicativo no navegador e digite um telefone vazio; observe se a mensagem aparece como `#phone-error`, como um toast, ou em outra parte.  <br>2. Se não aparecer como `#phone-error`, ajuste o seletor. |
| **3** | **Forçar a validação antes do envio** | Use `await page.press('#phone', 'Tab');` ou `await page.focus('#phone');` e `await page.blur('#phone');` para disparar a validação antes de enviar o formulário. |
| **3** | **Usar `expect(...).toHaveText` com `visible: true`** | Exemplo: `await expect(page.locator('#phone-error')).toHaveText('Phone is required.', { visible: true, timeout: 8000 });`  |
| **3** | **Adicionar logs de debugging** | Inicie o Playwright com `DEBUG=pw:api` para ver se a requisição está sendo enviada corretamente, ou insira `console.log(await page.content());` no teste para inspecionar o HTML no momento do erro. |

---

## 4. Checklist de boas práticas

1. **Seletores robustos** – Use `data-testid` ou atributos estáveis em vez de classes que mudam com a UI.  
2. **Timeouts escaláveis** – Evite hard‑code de 5 s/10 s; use o valor padrão (30 s) ou aumente apenas quando a aplicação realmente requer.  
3. **Validação de API** – Sempre combine verificações de UI com a resposta da API quando a ação depende de backend.  
4. **Regex em `toContainText`** – Quando o texto pode incluir variações, use expressões regulares: `await expect(locator).toContainText(/Phone is required/);`.  
5. **Logs detalhados** – Quando o teste falhar, capture a página (`await page.screenshot()` ou `await page.content()`) para facilitar o diagnóstico.  

Implementando essas correções, os testes deverão voltar a passar ou, no mínimo, falhar com mensagens mais claras e fáceis de depurar.