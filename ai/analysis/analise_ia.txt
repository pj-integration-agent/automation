**Resumo rápido**

| Teste | Resultado | Motivo | Sugestão |
|-------|-----------|--------|----------|
| Login inválido falhou | **Falhou** | Mensagem de erro esperada diferente da que a aplicação retornou | Ajustar a expectativa ou o código de negócio |
| Usuário deve atualizar telefone com campo vazio falhou | **Falhou** | O elemento de erro não foi encontrado | Garantir que o erro seja exibido (ou corrigir o seletor) |

---

## 1. Teste **“Login inválido falhou”**

### 1.1. O que aconteceu?
- O teste tentou verificar se o `<p class="error">` continha o texto:
  ```
  "An internal error has occurred and has been logged."
  ```
- O elemento realmente contava com:
  ```
  "The username and password could not be verified."
  ```
- O `expect(...).toContainText()` acabou falhando porque a string esperada não estava presente.

### 1.2. Por que a falha ocorreu?
1. **Mensagem de erro inesperada**  
   O backend/ front‑end mudou a mensagem de erro. O teste foi escrito com base na versão antiga (“An internal error...”) mas a aplicação atualiza o texto para “The username and password could not be verified.”
2. **Assertividade excessiva**  
   O `toContainText()` exige uma correspondência exata (ou pelo menos a substring), então qualquer variação (acentuação, pontuação, espaçamento) quebra o teste.

### 1.3. Como corrigir?
| Opção | Como aplicar | Quando usar |
|-------|--------------|-------------|
| **Ajustar a string esperada** | Substitua a mensagem no teste pelo texto atual: <br>`expect(locator('.error')).toContainText('The username and password could not be verified.');` | Se o erro atual for o comportamento desejado. |
| **Usar uma substring ou regex** | `expect(locator('.error')).toContainText(/username and password could not be verified/i);` | Quando o texto pode variar (ex.: inclusão de detalhes adicionais). |
| **Validar o código de erro** | Em vez de depender do texto, verifique um código de erro oculto ou atributo: <br>`expect(locator('.error')).toHaveAttribute('data-error', 'invalid_credentials');` | Quando a mensagem pode mudar, mas o código interno permanece o mesmo. |
| **Atualizar a aplicação** | Se o erro esperado for realmente “An internal error…”, corrija o back‑end para lançar essa mensagem. | Quando o teste está correto e o back‑end está fora de sincronia. |

> **Dica prática:** Use o comando `console.log(page.locator('.error').innerText())` antes da `expect()` para inspecionar o valor real durante a execução do teste.

---

## 2. Teste **“Usuário deve atualizar telefone com campo vazio falhou”**

### 2.1. O que aconteceu?
- O teste aguardou pelo elemento `//*[@id="phone-error"]` e esperava que ele contivesse a string `"Phone is required."`.
- O `playwright` nunca encontrou nenhum elemento com esse Xpath → **Timeout** + **Error: element(s) not found**.

### 2.2. Por que a falha ocorreu?
1. **Seleção incorreta**  
   O Xpath pode estar errado (por exemplo, a página usa um `id` diferente, ou o elemento é criado dinamicamente dentro de um componente React que não expõe `id="phone-error"`).
2. **Validação não acionada**  
   Talvez o teste não tenha executado a ação que dispara a validação (ex.: não clicou em “Save”, não saiu do campo, não enviou o formulário).
3. **Elemento não renderizado**  
   O erro pode aparecer somente após um certo tempo ou apenas em determinadas condições (por exemplo, após a chamada API). Se a página carregou antes da validação, o elemento ainda não existe.
4. **Escopo do teste**  
   Se o teste roda em um ambiente isolado (sandbox), a camada de validação pode ter sido removida ou alterada.

### 2.3. Como corrigir?
| Passo | O que fazer | Por que ajuda |
|-------|-------------|---------------|
| **1. Inspecionar o seletor** | Use o DevTools ou o `page.inspect()` para confirmar se existe um elemento com `id="phone-error"` quando a condição de erro ocorre. | Garante que o seletor esteja correto. |
| **2. Usar um seletor mais robusto** | `await expect(page.locator('p#phone-error')).toHaveText('Phone is required.');` ou `await expect(page.locator('text=Phone is required.')).toBeVisible();` | Evita dependência de Xpath que pode ser frágil. |
| **3. Gatilho da validação** | Certifique-se de que o teste deixe o campo vazio e então faça `await page.click('button#save');` ou `await page.press('input#phone', 'Enter');` antes de fazer o `expect()`. | Garantia de que a página realmente tenta salvar e mostra o erro. |
| **4. Esperar a renderização** | `await page.waitForSelector('p#phone-error', { state: 'visible', timeout: 5000 });` | Evita falhas de timing. |
| **5. Revisar o fluxo de validação** | Se o erro aparece dentro de um componente modal, certifique‑se de que o modal esteja aberto antes de procurar o elemento. | O erro pode estar em um contêiner oculto. |
| **6. Atualizar a aplicação** | Se o `id` mudou (ex.: de `phone-error` para `phone_error`), atualize o teste ou o componente para manter consistência. | Evita que o teste dependa de artefatos temporários. |

> **Exemplo corrigido:**
> ```ts
> // Deixar o campo vazio
> await page.fill('#phone', '');
> // Tentar salvar
> await page.click('#save-button');
> // Esperar erro
> await expect(page.locator('#phone-error')).toHaveText('Phone is required.');
> ```

---

## 3. Boas práticas gerais

1. **Separar dados de teste e lógica**  
   Use variáveis de configuração para mensagens de erro, de modo que alterações no back‑end exijam apenas uma alteração no arquivo de configuração, não em cada teste.

2. **Utilizar `toHaveText` em vez de `toContainText` quando a correspondência exata for importante**  
   `toHaveText` faz a verificação exata e pode ajudar a detectar diferenças sutis.

3. **Adicionar mensagens de erro detalhadas**  
   Em vez de apenas `Error: expect(locator).toContainText(...) failed`, inclua o valor real retornado (`Received string: "...")` no `expect()` para facilitar a depuração.

4. **Use `test.step()`**  
   Envolver cada ação em um `test.step()` ajuda a localizar exatamente onde o erro ocorre durante a execução do teste.

---

## Resumo de correções rápidas

| Teste | Ajuste imediato |
|-------|-----------------|
| Login inválido falhou | Substituir a string esperada por `"The username and password could not be verified."` (ou usar regex). |
| Atualizar telefone vazio | Garantir que o botão “Save” seja clicado depois de deixar o campo vazio e usar `#phone-error` como seletor, com `await expect(...)` após `page.waitForSelector(...)`. |

Ao seguir esses passos, os testes deverão passar novamente ou, se a aplicação realmente mudou o comportamento, o teste ficará alinhado ao novo fluxo.