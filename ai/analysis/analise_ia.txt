## 1. Testes que falharam

| Data e hora | Descrição do teste | Status |
|-------------|---------------------|--------|
| 2026‑01‑12 17:05:15 | **Login inválido falhou** – verificando a mensagem de erro na página de login | **Falhou** |
| 2026‑01‑12 17:05:17 | **Usuário deve atualizar telefone com campo vazio falhou** – verificando o erro de campo “telefone” | **Falhou** |

---

## 2. Motivo de cada falha

### 2.1. Teste “Login inválido falhou”

- **Expectativa**: a página deveria conter o texto  
  `An internal error has occurred and has been logged.`  
  (o texto está em negrito, com `⌈`/`⌉` de formatação de console).
- **Resultado real**:  
  O elemento `<p class="error">The username and password could not be verified.</p>` apareceu na página.
- **Problema**:  
  O texto esperado e o recebido são totalmente diferentes – parece que o teste foi escrito para um cenário de *erro interno* enquanto o fluxo real devolve um erro de *credenciais inválidas*.

### 2.2. Teste “Usuário deve atualizar telefone com campo vazio falhou”

- **Expectativa**: o erro de validação do campo “telefone” deveria aparecer com o texto  
  `Phone is required.`
- **Resultado real**:  
  - O seletor `//*[@id="phone-error"]` não encontrou nenhum elemento na página (erro *element(s) not found*).  
  - Mesmo que o elemento tivesse sido encontrado, o texto esperado não estava presente.
- **Problema**:  
  - O campo de erro não está sendo renderizado (possivelmente há um bug de validação ou o ID mudou).  
  - Se o elemento estivesse lá, o texto seria diferente (talvez em português ou em outro idioma).

---

## 3. Sugestões de correção

### 3.1. Corrigindo o teste de login inválido

1. **Verificar qual erro realmente deve aparecer**  
   - Se a aplicação devolve a mensagem “The username and password could not be verified.” quando as credenciais são inválidas, o teste deve ser ajustado para esperar essa mensagem.  
   - Caso contrário, se o erro interno for realmente esperado, garanta que o fluxo de teste realmente gera esse erro (por exemplo, provocando uma falha de backend).

2. **Atualizar o `expect`**  
   ```ts
   // Exemplo de ajuste
   await expect(page.locator('.error')).toContainText(
     'The username and password could not be verified.'
   );
   ```

3. **Adicionar logs mais claros**  
   - Use `await page.waitForSelector('.error', {timeout: 5000});` antes do `expect` para garantir que o elemento tenha tempo de aparecer.

4. **Verificar a localidade**  
   - Se a aplicação suporta vários idiomas, verifique se o texto esperado corresponde à localidade configurada no teste.

### 3.2. Corrigindo o teste de telefone em branco

1. **Confirmar o seletor**  
   - Abra a página no dev‑tools e verifique se o elemento de erro realmente tem `id="phone-error"` ou se mudou (ex.: `id="error-phone"`).  
   - Se mudou, atualize o seletor no teste:

   ```ts
   await expect(page.locator('#error-phone')).toContainText('Phone is required.');
   ```

2. **Garantir que a validação é acionada**  
   - Certifique-se de que o teste está submetendo o formulário com o campo de telefone vazio antes de verificar o erro.  
   - Exemplo:
     ```ts
     await page.fill('#phone', '');
     await page.click('#update-phone-button');
     ```

3. **Aumentar o timeout se necessário**  
   - Se a validação envolve chamadas AJAX, pode ser necessário esperar mais:
     ```ts
     await expect(page.locator('#phone-error')).toContainText('Phone is required.', {timeout: 8000});
     ```

4. **Revisar mensagens de erro**  
   - Se a mensagem de erro aparecer em português (ex.: “Telefone é obrigatório.”), ajuste o texto esperado:
     ```ts
     await expect(page.locator('#phone-error')).toContainText('Telefone é obrigatório.');
     ```

5. **Adicionar fallback de inspeção**  
   - Caso o elemento apareça de forma condicional (ex.: apenas após blur), use `await page.blur('#phone')` antes de verificar.

---

## 4. Checklist de boas práticas para evitar falhas futuras

| Item | Ação | Por que isso ajuda |
|------|------|--------------------|
| **1. Centralizar textos de erro** | Mantenha um arquivo de constantes (ex.: `ERROR_MESSAGES.ts`) com todas as mensagens de erro. | Evita divergências entre o que o teste espera e o que a UI mostra. |
| **2. Testar em múltiplas localizações** | Se a aplicação tem internacionalização, configure o locale no contexto do Playwright antes de cada teste. | Garante que as mensagens correspondem ao idioma configurado. |
| **3. Verificar seletor antes de usar** | Use `await expect(page.locator(seletor)).toBeVisible()` antes de fazer `toContainText`. | Assegura que o elemento existe e está visível, reduzindo erros “element not found”. |
| **4. Log detalhado** | Adicione `page.on('console', msg => console.log(msg.text()))` ou use `console.log` antes de cada `expect`. | Facilita o diagnóstico rápido de por que um elemento não está onde se espera. |
| **5. Refatorar testes com page objects** | Crie uma classe `LoginPage`, `UserProfilePage` etc. com métodos `login(email, pw)`, `updatePhone(number)`. | Encapsula a lógica de interação e torna os testes mais legíveis e menos propensos a quebrar com mudanças de UI. |

Aplicando essas correções e boas práticas, você reduzirá a taxa de falhas por mudanças de textos ou seletores e aumentará a estabilidade geral dos testes Playwright.