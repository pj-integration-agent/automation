## 1️⃣ Testes que falharam  

| # | Nome do Teste | Linha do Log | Falha Reportada |
|---|---------------|--------------|-----------------|
| 1 | **Login inválido falhou** | 2025‑12‑12T20:13:11 | `expect(locator('.error')).toContainText()` não encontrou o texto esperado. |
| 2 | **Usuário deve atualizar telefone com campo vazio falhou** | 2025‑12‑12T20:13:13 | `expect(locator('//*[@id="phone-error"]')).toContainText()` não encontrou o elemento nem o texto esperado. |

---

## 2️⃣ Motivo de cada falha  

### 2.1 “Login inválido falhou”

* **O que foi esperado**  
  *Elemento com seletor `.error` contendo a substring*  
  `"An internal error has occurred and has been logged."`

* **O que realmente aconteceu**  
  O Playwright encontrou o elemento `<p class="error">The username and password could not be verified.</p>` e verificou o texto completo. O texto **não** coincidia com o esperado, resultando em erro de comparação.

* **Causas probáveis**  
  1. **Mensagem de erro do aplicativo mudou** – talvez a aplicação agora exibe *“The username and password could not be verified.”* em vez da mensagem “An internal error…”.  
  2. **Teste está hard‑coded** – o valor esperado foi codificado no teste e não reflete o comportamento real.  
  3. **Ambiente de teste diferente** – se o teste foi rodado em um ambiente com configuração de erro diferente (por ex., staging vs produção).

### 2.2 “Usuário deve atualizar telefone com campo vazio falhou”

* **O que foi esperado**  
  *Elemento com id `phone-error` contendo a substring*  
  `"Phone is required."`

* **O que realmente aconteceu**  
  Playwright não encontrou nenhum elemento que correspondesse ao XPath `//*[@id="phone-error"]` dentro do timeout de 5 s. Consequentemente, a verificação de texto não foi executada.

* **Causas probáveis**  
  1. **O erro de telefone não é exibido** – o formulário pode estar usando outro seletor (classe, data‑attribute, etc.) ou exibindo a mensagem em outro lugar.  
  2. **Tempo de renderização** – a mensagem aparece depois de um atraso maior que 5 s, talvez devido a uma chamada assíncrona de validação.  
  3. **Campo “phone” não disparou a validação** – a ação de “salvar” ou “submeter” pode não ter sido executada corretamente, então o erro nunca aparece.  
  4. **Seleção XPath errada** – o XPath pode estar incorreto (ex.: `id` em vez de `@id`, ou o elemento não tem id exatamente “phone-error”).

---

## 3️⃣ Sugestões para correção  

### 3.1 Correção do teste de login

| Passo | O que fazer | Por quê |
|-------|-------------|---------|
| **a. Atualizar texto esperado** | Verifique o aplicativo (console, logs, UI) qual mensagem aparece após login inválido. | Evitar hard‑coding de mensagens que mudam com frequência. |
| **b. Usar `toContainText` com substring** | Se a mensagem pode variar (ex.: incluir códigos de erro), use `toContainText('verified')` ou `toContainText(/verified/i)` | Permite flexibilidade e reduz falhas por pequenas mudanças de texto. |
| **c. Verificar o seletor** | Certifique-se de que `.error` é o seletor correto em todas as páginas. Se há múltiplos `<p class="error">`, adicione um contexto (`locator('.error').first()` ou `locator('.error', {hasText: 'The username'})`). | Evita confundir elementos. |
| **d. Aumentar timeout ou usar `waitForSelector`** | Caso a mensagem demore mais que 5 s, aumente o timeout (`.toContainText('...', {timeout: 10000})`). | Garante que o teste espere o elemento aparecer. |

#### Exemplo de código corrigido

```ts
// Espera a mensagem de erro aparecer e verifica se contém a substring esperada
await expect(page.locator('.error')).toContainText(
  /verified/i,          // substring flexível
  { timeout: 10000 }    // 10s, se necessário
);
```

### 3.2 Correção do teste de telefone vazio

| Passo | O que fazer | Por quê |
|-------|-------------|---------|
| **a. Conferir o seletor** | Abra o devtools e procure por `<span id="phone-error">` ou outro elemento. Use o seletor mais estável (classe, `data-test-id`, etc.). | Evita falhas por XPath errado. |
| **b. Verificar a lógica de validação** | Execute manualmente a submissão do formulário vazio e observe onde a mensagem aparece (ex.: em um modal, em um tooltip). | Garante que o teste esteja acionando a mesma rota de validação. |
| **c. Ajustar o timeout** | Se o erro aparece após um AJAX ou debounce, aumente o timeout (`{timeout: 10000}`) ou use `waitForTimeout(2000)` antes da verificação. | Dá tempo para a mensagem renderizar. |
| **d. Usar `waitForSelector` antes de `toContainText`** | `await expect(page.locator('#phone-error')).toBeVisible({timeout: 10000});` | Garante que o elemento já esteja no DOM. |
| **e. Substituir XPath por CSS** | Preferencialmente use `page.locator('#phone-error')` em vez de XPath. | Código mais legível e menos propenso a erros. |

#### Exemplo de código corrigido

```ts
// 1. Submete o formulário com telefone vazio
await page.fill('#phone', '');      // garante campo vazio
await page.click('#save-phone');    // botão de salvar

// 2. Espera a mensagem de erro aparecer
const phoneError = page.locator('#phone-error');
await expect(phoneError).toBeVisible({ timeout: 8000 });

// 3. Verifica o texto
await expect(phoneError).toContainText('Phone is required.');
```

---

## Resumo rápido

| Teste | Falha | Motivo | Correção imediata |
|-------|-------|--------|-------------------|
| Login inválido | Texto inesperado | Mensagem mudou; hard‑coding | Atualizar string esperada / usar regex |
| Atualizar telefone vazio | Elemento não encontrado | XPath incorreto / renderização tardia | Usar `#phone-error`, aumentar timeout, verificar lógica de validação |

Implementando essas mudanças você reduzirá a taxa de falhas por razões de UI que mudam de forma inesperada e aumentará a robustez dos seus testes Playwright. Boa codificação!