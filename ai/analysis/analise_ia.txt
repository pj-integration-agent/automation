## 1. Testes que falharam

| ID do teste | Descrição |
|-------------|-----------|
| **Login inválido falhou** | Verifica se a mensagem de erro aparece quando o usuário tenta fazer login com credenciais inválidas. |
| **Usuário deve atualizar telefone com campo vazio falhou** | Garante que a aplicação exiba uma mensagem de validação quando o usuário tenta atualizar o telefone deixando o campo em branco. |

## 2. Motivo de cada falha

### 2.1 `Login inválido falhou`

- **O que aconteceu?**  
  O Playwright buscou o elemento `<p class="error">The username and password could not be verified.</p>` (usando o seletor `.error`).  
  O teste, entretanto, estava **esperando** a substring:

  ```
  "An internal error has occurred and has been logged."
  ```

  Como as duas strings não coincidem, o `expect(...).toContainText(...)` falhou, mesmo que o elemento tenha sido encontrado no tempo de 5 s.

- **Por que isso ocorreu?**  
  1. **Mudança de mensagem do backend** – O site passou a usar a frase “The username and password could not be verified.” em vez de “An internal error has occurred …”.  
  2. **Teste desatualizado** – O arquivo de teste continua esperando a mensagem antiga, talvez por ter sido criado antes da mudança.  
  3. **Ambiente de teste diferente** – Se a aplicação roda em múltiplas localizações (por ex.: inglês vs. português), o texto pode variar conforme a cultura configurada.

### 2.2 `Usuário deve atualizar telefone com campo vazio falhou`

- **O que aconteceu?**  
  O teste procurou pelo elemento `//*[@id="phone-error"]` e, em 5 s, não encontrou nenhum nó correspondente. Como o elemento não aparece, o `toContainText` não tem texto para comparar, resultando na falha.

- **Por que isso ocorreu?**  
  1. **Seleção incorreta** – O id real pode ser diferente (ex.: `phone-error` vs. `phone-error-msg`).  
  2. **Validação não disparou** – A página pode precisar de um evento (por ex.: blur ou submit) antes de gerar a mensagem de erro.  
  3. **Elemento oculto** – O erro pode existir no DOM mas estar com `display:none` ou `visibility:hidden`. O Playwright ainda considera isso um “element not found” se o seletor não corresponder a um nó visível, a menos que você use `force:true`.  
  4. **Falha de fluxo** – Se o botão “Atualizar telefone” está desabilitado enquanto o campo está vazio, o teste pode ter clicado antes que a validação ocorresse.

## 3. Sugestões de correção

### 3.1 Corrigindo o teste de login inválido

1. **Atualize o texto esperado**  
   ```ts
   await expect(page.locator('.error')).toContainText('The username and password could not be verified.');
   ```

   Se a mensagem pode variar (ex.: pode mostrar “An internal error” em casos de falha de servidor), considere usar uma expressão regular ou um *partial match*:
   ```ts
   await expect(page.locator('.error')).toContainText(/password could not be verified|internal error/i);
   ```

2. **Verifique o ambiente**  
   Assegure‑se de que o teste roda na mesma localidade que o ambiente de teste. Se for um aplicativo multilíngue, use um *locale* consistente ou extraia o texto da interface atual e compare com um dicionário de mensagens.

3. **Use mensagens de erro globais**  
   Se o projeto possui um arquivo de *i18n* ou constantes, importe‑o no teste em vez de escrever o texto estático. Assim, quando a mensagem mudar, o teste não falhará.

### 3.2 Corrigindo o teste de atualização de telefone

1. **Confirme o seletor**  
   Abra o navegador devtools, verifique o id real do elemento de erro (ex.: `phone-error-msg`) e atualize o seletor:
   ```ts
   const errLocator = page.locator('#phone-error-msg');
   ```

2. **Forçar a exibição**  
   Se o elemento existir mas estiver oculto, use:
   ```ts
   await expect(errLocator).toBeVisible({ timeout: 8000 });
   ```
   Ou, se necessário, use `force: true` ao buscar:
   ```ts
   const errLocator = page.locator('#phone-error-msg', { force: true });
   ```

3. **Dispare a validação**  
   Antes de verificar a mensagem, garanta que o campo de telefone tenha sido “perdido” (blur) ou que o formulário tenha sido submetido:
   ```ts
   await page.fill('#phone', '');
   await page.press('#phone', 'Tab'); // faz blur
   await page.click('#update-phone-btn');
   ```

4. **Aumente o timeout se necessário**  
   Se a validação leva mais tempo (ex.: chamada AJAX), aumente o timeout:
   ```ts
   await expect(errLocator).toContainText('Phone is required.', { timeout: 12000 });
   ```

5. **Use `waitForSelector`**  
   Se o erro é criado dinamicamente, use:
   ```ts
   await page.waitForSelector('#phone-error-msg', { state: 'visible', timeout: 12000 });
   ```

### 3.3 Boas práticas gerais

| Prática | Por que é útil |
|---------|----------------|
| **Extrair mensagens de um arquivo de constantes** | Evita “hard‑coding” de textos, facilita manutenção. |
| **Testar apenas a funcionalidade** | Se o objetivo é “não deixar telefone vazio”, basta verificar que o botão fica desabilitado ou que a validação dispara; não é necessário testar todo o fluxo de UI. |
| **Logs detalhados** | Adicione `console.log(page.url(), await page.content())` antes das asserções para ter contexto em caso de falha. |
| **Timeouts explicítos** | Use `{ timeout: 8000 }` quando espera algo que pode demorar, mas mantenha 5 s para a maioria das interações. |
| **Fallback de idioma** | Se o app pode mudar de idioma, use `page.evaluate(() => document.documentElement.lang)` para ajustar o texto esperado. |

## Resumo

1. **Login inválido falhou** – Porque o texto esperado não corresponde ao que a aplicação realmente retorna.  
   *Corrija atualizando o texto ou usando correspondência parcial.*

2. **Usuário deve atualizar telefone com campo vazio falhou** – Porque o elemento de erro não foi localizado (seleção ou fluxo de validação).  
   *Corrija validando o seletor, forçando a exibição ou disparando a validação corretamente.*

Com esses ajustes, os testes deverão passar de forma consistente e refletir corretamente o comportamento atual da aplicação.