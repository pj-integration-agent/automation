## 1. Testes que falharam

| Data e hora | Nome do teste (em português) | Status |
|-------------|------------------------------|--------|
| 2025‑11‑25 16:46:29 | **Login inválido falhou** | **Falhou** |
| 2025‑11‑25 16:46:31 | **Usuário deve atualizar telefone com campo vazio falhou** | **Falhou** |

---

## 2. Motivo de cada falha

### a) Login inválido falhou

- **Expectativa**:  
  `expect(locator('.error')).toContainText("An internal error has occurred and has been logged.")`

- **Resultado real**:  
  O elemento `<p class="error">The username and password could not be verified.</p>` foi encontrado, e o texto obtido foi **“The username and password could not be verified.”**  

- **Causa**:  
  O texto exibido pelo aplicativo não corresponde ao substring esperado. Isso pode ocorrer porque:
  1. A mensagem de erro foi alterada (ou nunca foi “An internal error …”).
  2. Há um bug no código que mostra a mensagem errada quando o login falha.
  3. O teste foi escrito com base em um requisito desatualizado.

### b) Usuário deve atualizar telefone com campo vazio falhou

- **Expectativa**:  
  `expect(locator('//*[@id="phone-error"]')).toContainText("Phone is required.")`

- **Resultado real**:  
  O Playwright não conseguiu localizar nenhum elemento que corresponda ao XPath `//*[@id="phone-error"]` dentro de 5 s. O erro reportado é **“element(s) not found”**.

- **Causa**:  
  1. O elemento de erro pode estar usando um ID diferente (por exemplo, `id="phone-error"` não existe).  
  2. O campo de telefone pode não disparar a validação de forma automática (precisa de blur, submit, etc.).  
  3. A página pode estar renderizando o elemento com atraso superior ao timeout padrão.  
  4. O teste pode estar apontando para um elemento que só aparece em um fluxo de UI específico (ex.: em um modal que não está aberto).

---

## 3. Sugestões de correção

### a) Falha no login

| Problema | Correção proposta |
|----------|-------------------|
| Texto esperado está incorreto | 1. **Atualizar o teste** com o texto real: `toContainText("The username and password could not be verified.")`.<br>2. Se o texto “An internal error …” deve ser exibido, **verificar o código‑backend** e garantir que ele seja disparado ao detectar erro interno. |
| Possível flutuação no erro (ex.: mensagem de erro genérica vs específica) | 1. Use **assertion mais permissivo**, por exemplo: `expect(locator('.error')).toContainText(/verified|internal error/i)`.<br>2. Se a mensagem pode variar, validar **classe, código de erro ou status** em vez do texto puro. |
| Falta de sincronização (mensagem ainda não renderizada) | 1. Adicionar `await page.waitForSelector('.error', { state: 'visible', timeout: 8000 })` antes da asserção.<br>2. Usar `expect(locator('.error')).toBeVisible()` para garantir que o elemento apareceu. |

**Exemplo de código corrigido (escrita em TypeScript):**
```ts
await page.waitForSelector('.error', { state: 'visible', timeout: 8000 });
await expect(page.locator('.error')).toContainText(
  /The username and password could not be verified|An internal error has occurred/i
);
```

---

### b) Falha na validação de telefone

| Problema | Correção proposta |
|----------|-------------------|
| XPath errado ou elemento inexistente | 1. Verifique a **estrutura HTML** real no DevTools.<br>2. Se o elemento possui `id="phone-error"`, use um seletor CSS simples: `locator('#phone-error')`.<br>3. Se o elemento tem outro identificador (ex.: `data-testid="phone-error"`), altere o seletor: `locator('[data-testid="phone-error"]')`. |
| Validação não disparada automaticamente | 1. **Simule o blur** do campo de telefone: `await page.locator('#phone').blur();`.<br>2. Ou submeta o formulário antes de verificar: `await page.getByRole('button', { name: /submit/i }).click();`. |
| Elemento aparece após atraso | 1. Aumente o timeout: `await page.waitForSelector('#phone-error', { timeout: 10000 });`. <br>2. Use `expect(page.locator('#phone-error')).toBeVisible({ timeout: 10000 });`. |
| Teste não cobre fluxo correto | 1. Verifique se o modal ou página onde o erro aparece está **aberto** antes da asserção. <br>2. Caso esteja em um modal, faça `await page.click('text=Edit Phone');` antes de enviar o formulário vazio. |

**Exemplo de código corrigido:**
```ts
// Certifique‑se de que o campo de telefone está vazio
await page.fill('#phone', '');

// Forçar a validação (blur ou submit)
await page.locator('#phone').blur(); // ou: await page.click('button[type="submit"]');

// Esperar que a mensagem de erro apareça
const phoneError = page.locator('#phone-error');
await expect(phoneError).toBeVisible({ timeout: 8000 });
await expect(phoneError).toContainText('Phone is required.');
```

---

## 4. Boas práticas adicionais

1. **Usar locators nomeados**  
   - Em vez de XPaths, prefira locators CSS ou os helpers do Playwright (`page.getByText`, `page.getByRole`, `page.getByTestId`).

2. **Captura de screenshots e logs**  
   - Em cada falha, habilite `await test.info().attach('screenshot', { path: await page.screenshot() });` para facilitar a investigação.

3. **Timeouts adequados**  
   - Se a aplicação tem carregamento lento, aumente o timeout global (`test.setTimeout(20000)`) ou use `timeout` específico nos `waitFor` e `expect`.

4. **Verificações de visibilidade**  
   - Antes de testar o texto, verifique se o elemento está visível: `await expect(locator).toBeVisible();`.

5. **Centralizar mensagens de erro**  
   - Se as mensagens de erro são geradas por um arquivo de recursos ou um serviço, mantê‑las centralizadas facilita a atualização de testes.

---

**Resumo**  
- **Login inválido** falhou por **texto de erro diferente**.  
- **Telefone vazio** falhou porque o **seletor não encontrou o elemento**.  
- Ajustar o **texto esperado** e **seletor** (ou a lógica de disparo da validação) resolve ambos os testes.