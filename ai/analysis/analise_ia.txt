**1. Testes que falharam**  
| # | Nome do teste | Data & Hora | Resumo do erro |
|---|---------------|-------------|----------------|
| 1 | **Login inválido falhou** | 2026‑01‑12 17:08:24 | `expect(locator('.error')).toContainText(...)` não encontrou a mensagem esperada. |
| 2 | **Usuário deve atualizar telefone com campo vazio falhou** | 2026‑01‑12 17:08:25 | `expect(locator('//*[@id="phone-error"]')).toContainText(...)` não encontrou o elemento `<p id="phone-error">`. |

> **Portanto, os dois testes de fluxo de UI que estavam sendo executados falharam.**

---

**2. Motivo de cada falha**

| # | Problema | Evidência no log | Interpretação |
|---|-----------|------------------|---------------|
| 1 | **Mensagem de erro incorreta** | <br>• `Expected substring: "An internal error has occurred and has been logged."` <br>• `Received string: "The username and password could not be verified."` | O teste está esperando que o sistema retorne uma mensagem de *erro interno*. No entanto, a aplicação devolve a mensagem típica de “credenciais inválidas”. O mismatch de texto faz o `toContainText` falhar. |
| 2 | **Elemento não encontrado** | <br>• `Locator: locator('//*[@id="phone-error"]')` <br>• `Error: element(s) not found` <br>• `Waiting for locator('//*[@id="phone-error"]')` | O elemento com `id="phone-error"` não está presente no DOM no momento em que o `toContainText` é executado. Pode ser que: <br>• o formulário não esteja enviando o erro (a validação não dispara); <br>• a mensagem aparece em outro seletor ou com outro id; <br>• o elemento está escondido ou removido antes da verificação; <br>• o teste está sendo executado antes da página ter terminado de renderizar o erro. |

---

**3. Sugestões de correção**

### Teste 1 – Login inválido

| Passo | O que fazer | Por quê |
|-------|-------------|---------|
| 1. **Verifique a mensagem real** | Abra a aplicação manualmente, tente um login inválido e capture a mensagem exibida. | Confirma qual texto realmente aparece. |
| 2. **Atualize a expectativa do teste** | Altere o `expected` para a string real (“The username and password could not be verified.”) ou, melhor, para uma substring mais genérica: `expect(locator('.error')).toContainText('The username and password could not be verified')`. | Evita falhas futuras por pequenas alterações de texto. |
| 3. **Use `toHaveText` se o elemento for estático** | Se a mensagem não mudar, `toHaveText` pode ser mais robusto. | Garante que o texto completo seja exatamente o esperado. |
| 4. **Adicione `await` e `waitForSelector`** | ```await page.waitForSelector('.error', { state: 'visible', timeout: 6000 });``` | Garante que o elemento exista antes de validar. |
| 5. **Tire capturas de tela** | `await page.screenshot({ path: 'login-error.png' });` | Facilita a depuração futura. |
| 6. **Considere testes de API** | Se a aplicação tem API separada para login, teste‑a direto para validar a mensagem. | Isola a camada de UI. |

### Teste 2 – Atualizar telefone com campo vazio

| Passo | O que fazer | Por quê |
|-------|-------------|---------|
| 1. **Confirme o seletor** | Inspecione o DOM após a tentativa de salvar telefone vazio. Verifique se o erro aparece em `<p id="phone-error">` ou em outro elemento. | Se o id mudou, o seletor está errado. |
| 2. **Use um seletor CSS em vez de XPath** | ```await expect(page.locator('#phone-error')).toBeVisible();``` | XPath tende a ser mais frágil e pode ter erros de sintaxe. |
| 3. **Verifique a lógica de validação** | Assegure‑se que a aplicação realmente dispara a mensagem de erro quando o campo está vazio. | Se a validação só acontece após submit, faça o submit antes do `expect`. |
| 4. **Aguarde o erro aparecer** | ```await page.waitForSelector('#phone-error', { timeout: 8000 });``` | O erro pode demorar a renderizar, especialmente em redes lentas. |
| 5. **Use `toContainText` com substring** | ```await expect(page.locator('#phone-error')).toContainText('Phone is required');``` | Se o texto completo mudar, a substring continua válida. |
| 6. **Teste a visibilidade antes da verificação** | ```await expect(page.locator('#phone-error')).toBeVisible();``` | Garante que o erro não só exista, mas seja visível ao usuário. |
| 7. **Revisar a implementação de validação** | Se o elemento não está sendo renderizado, talvez o código de validação esteja falhando. | Corrigir o bug na aplicação. |

### Boas práticas gerais

1. **Timeouts adequados**  
   - Aumente o timeout para 8‑10 s se a aplicação for lenta.  
   - Use `page.setDefaultTimeout(10000);` no `beforeAll` ou `beforeEach`.

2. **Logs visuais**  
   - Capture screenshots ou gravações de vídeo quando um teste falhar (`test.info().attach(...)`).

3. **Assertions mais robustas**  
   - `toHaveText` e `toBeVisible` ajudam a capturar casos em que o texto aparece mas o elemento não é visível.  
   - `toContainText` funciona bem para substrings, mas cuidado com textos muito longos ou formatados.

4. **Separação de responsabilidades**  
   - Se o teste depende de dados que podem mudar (por exemplo, mensagem de erro), considere extrair essas mensagens de um arquivo de constantes ou usar mocks de API para garantir consistência.

---

**Resumo rápido**

| Teste | Falha | Correção imediata |
|-------|-------|-------------------|
| Login inválido | Texto esperado diferente do real | Atualizar o `expected` ou usar substring mais genérica |
| Atualizar telefone | Elemento `#phone-error` não encontrado | Confirmar seletor, aguardar visibilidade, corrigir validação ou ajustar o teste |

Implementando essas correções, os testes deverão passar e ficarão mais resilientes a mudanças na interface ou nas mensagens de erro.